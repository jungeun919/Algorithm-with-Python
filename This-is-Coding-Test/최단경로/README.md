# Shortest Path

* 최단 경로 알고리즘을 말 그대로 가장 짧은 경로를 찾는 알고리즘
* 보통 그래프를 이용해 표현하는데 각 지점은 '노드'로 표현되고, 지점간 연결된 도로는 '간선'으로 표현
* 최단 거리 알고리즘 : 다익스트라 최단 경로 알고리즘, 플로이드 워셜, 벨만 포드 알고리즘

# 다익스트라(Dijkstra) 최단 경로 알고리즘 (간단 ver)
* 여러 개의 노드가 있을 떄, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘
* 음의 간선이 없을 때 정상적으로 작동
* 알고리즘 원리 (그리디 알고리즘으로 분류)
	* 출발 노드 설정
	* 최단 거리 테이블(distance) 초기화 -> 무한 값
	* 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택 (3)
	* 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블 갱신 (4)
	* (3), (4)를 반복
* 특징
	* 한 단계당(한 노드를 선택하고 최단 거리 테이블을 갱신) 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있음
* 관련 변수 설정
	* graph : 각 노드와 연결된 노드에 대한 정보를 (노드, 비용) 형태로 저장한 2차원 배열
	* visited : 각 노드에 대해 방문 여부를 체크하는 리스트, True, False로 저장
	* distance : 최단 거리 테이블 리스트
* 시간복잡도 : O(노드 수 ^ 2)

# 다익스트라(Dijkstra) 최단 경로 알고리즘 (개선 ver)
* 위와 동일한 방식
* 다른점
	* 최단 거리가 가장 짧은 노드를 찾기 위해, 이전엔 최단 거리 테이블을 선형적으로 모두 탐색
	* 우선순위 큐를 구현하기 위해 힙 자료구조 사용
	* 파이썬 라이브러리는 기본적으로 최소 힙 구조를 이용
	* (가치, 물건) 형태로 저장된 경우, '가치' 값이 낮은 순서로 꺼냄
	* 
		|우선순위 큐 구현 방식|삽입 시간|삭제 시간|
		|---|---|---|
		|리스트|O(1)|O(N)|
		|힙|O(log N)|O(log N)|

	* 현재 가장 가까운 노드를 저장하기 위한 목적으로만 우선순위 큐를 추가로 이용
	* 즉, 최단 거리가 가장 짧은 노드를 선택하는 과정에서 사용
* 관련 변수 설정
	* graph : 각 노드와 연결된 노드에 대한 정보를 (노드, 비용) 형태로 저장한 2차원 배열
	* distance : 최단 거리 테이블 리스트
	* q : 우선순위 큐
	* dist, now == (거리, 노드) : heapq를 이용한 우선순위 큐(q)의 원소
* 시간복잡도 : 최악의 경우에도 O(간선 수 * log 노드 수) 보장

# 플로이드 워셜(Floyd-Warshall) 알고리즘
* 다익스트라 알고리즘은 '한 지점에서 다른 특정 지점까지의 최단 경로를 구하는 경우' 이용
* 플로이드 워셜은 '모든 지점에서 다른 모든 지점까지의 최단 경로를 구혀는 경우' 이용
* 알고리즘 원리 (다이나믹 프로그래밍으로 분류)
	* 거쳐 가는 노드를 기준으로 알고리즘 수행
	* 노드의 개수가 N개일 때, N번의 단계를 수행
	* 각 단계마다 O(N^2) 연산을 통해 현재 노드를 거쳐가는 모든 경로를 고려
	* 점화식 -> Dab = min(Dab, Dak + Dkb)
* 관련 변수 설정
	* graph : 2차원 리스트로 그래프 표현

* 시간복잡도 : O(노드 수 ^ 3)